package cluster

import (
	"bytes"
	"context"
	"io/ioutil"
	"net"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/dimaunx/armada/pkg/config"
	dockertypes "github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	dockerclient "github.com/docker/docker/client"
	"github.com/gobuffalo/packr/v2"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v2"
	kind "sigs.k8s.io/kind/pkg/cluster"
)

type kubeConfig struct {
	APIVersion string `yaml:"apiVersion"`
	Clusters   []struct {
		Cluster struct {
			CertificateAuthorityData string `yaml:"certificate-authority-data"`
			Server                   string `yaml:"server"`
		} `yaml:"cluster"`
		Name string `yaml:"name"`
	} `yaml:"clusters"`
	Contexts []struct {
		Context struct {
			Cluster string `yaml:"cluster"`
			User    string `yaml:"user"`
		} `yaml:"context"`
		Name string `yaml:"name"`
	} `yaml:"contexts"`
	CurrentContext string `yaml:"current-context"`
	Kind           string `yaml:"kind"`
	Preferences    struct {
	} `yaml:"preferences"`
	Users []struct {
		Name string `yaml:"name"`
		User struct {
			ClientCertificateData string `yaml:"client-certificate-data"`
			ClientKeyData         string `yaml:"client-key-data"`
		} `yaml:"user"`
	} `yaml:"users"`
}

// PrepareKubeConfigs modifies kubconfig file generated by kind and returns the kubeconfig file path
func PrepareKubeConfigs(clName string, sourceKubeConfigFilePath, masterIP string) error {
	var kubeconf kubeConfig
	currentDir, _ := os.Getwd()

	_ = os.MkdirAll(config.LocalKubeConfigDir, os.ModePerm)
	_ = os.MkdirAll(config.ContainerKubeConfigDir, os.ModePerm)
	kindKubeFileName := strings.Join([]string{"kind-config", clName}, "-")
	newLocalKubeFilePath := filepath.Join(currentDir, config.LocalKubeConfigDir, kindKubeFileName)
	newContainerKubeFilePath := filepath.Join(currentDir, config.ContainerKubeConfigDir, kindKubeFileName)

	sourceKubeFile, err := ioutil.ReadFile(sourceKubeConfigFilePath)
	if err != nil {
		return errors.Wrapf(err, "failed to read kube config %s.", sourceKubeConfigFilePath)
	}

	err = yaml.Unmarshal(sourceKubeFile, &kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to read kube config %s.", sourceKubeConfigFilePath)
	}

	kubeconf.CurrentContext = clName
	kubeconf.Contexts[0].Name = clName
	kubeconf.Contexts[0].Context.Cluster = clName
	kubeconf.Contexts[0].Context.User = clName
	kubeconf.Clusters[0].Name = clName
	kubeconf.Users[0].Name = clName

	d, err := yaml.Marshal(&kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to marshal kube config.")
	}

	err = ioutil.WriteFile(newLocalKubeFilePath, d, 0644)
	if err != nil {
		return errors.Wrapf(err, "failed to save kube config %s.", newLocalKubeFilePath)
	}

	kubeconf.Clusters[0].Cluster.Server = "https://" + masterIP + ":6443"
	d, err = yaml.Marshal(&kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to marshal kube config.")
	}

	err = ioutil.WriteFile(newContainerKubeFilePath, d, 0644)
	if err != nil {
		return errors.Wrapf(err, "failed to save kube config %s.", newContainerKubeFilePath)
	}
	return nil
}

// GetKubeConfigPath returns different kubeconfig paths for local and docker based runs
func GetKubeConfigPath(clName string) (string, error) {
	currentDir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	// Dummy destination
	conn, err := net.Dial("udp", "1.1.1.1:80")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	localAddr := conn.LocalAddr().(*net.UDPAddr)
	ctx := context.Background()
	dockerCli, err := dockerclient.NewEnvClient()
	if err != nil {
		return "", err
	}

	networkFilter := filters.NewArgs()
	networkFilter.Add("driver", "bridge")
	networks, err := dockerCli.NetworkList(ctx, dockertypes.NetworkListOptions{Filters: networkFilter})
	if err != nil {
		return "", err
	}

	for _, network := range networks {
		dockerNet := network.IPAM.Config[0].Subnet
		_, ipNet, err := net.ParseCIDR(dockerNet)
		if err != nil {
			return "", err
		}

		if ipNet.Contains(localAddr.IP) {
			log.Debugf("Running in a container. Bridge network: %s, ip: %s.	", dockerNet, localAddr.IP)
			kubeConfigFilePath := filepath.Join(currentDir, config.ContainerKubeConfigDir, strings.Join([]string{"kind-config", clName}, "-"))
			return kubeConfigFilePath, nil
		}
	}
	log.Debugf("Running in a host mode. ip: %s.", localAddr.IP)
	kubeConfigFilePath := filepath.Join(currentDir, config.LocalKubeConfigDir, strings.Join([]string{"kind-config", clName}, "-"))
	return kubeConfigFilePath, nil
}

// GetMasterDockerIP gets control plain master docker internal ip
func GetMasterDockerIP(clName string) (string, error) {
	ctx := context.Background()
	dockerCli, err := dockerclient.NewEnvClient()
	if err != nil {
		return "", err
	}

	containerFilter := filters.NewArgs()
	containerFilter.Add("name", strings.Join([]string{clName, "control-plane"}, "-"))
	containers, err := dockerCli.ContainerList(ctx, dockertypes.ContainerListOptions{
		Filters: containerFilter,
		Limit:   1,
	})
	if err != nil {
		return "", err
	}
	return containers[0].NetworkSettings.Networks["bridge"].IPAddress, nil
}

// iterate func map for config template
func iterate(start, end int) (stream chan int) {
	stream = make(chan int)
	go func() {
		for i := start; i <= end; i++ {
			stream <- i
		}
		close(stream)
	}()
	return
}

// GenerateCalicoDeploymentFile generates calico deployment file from template
func GenerateCalicoDeploymentFile(cl *config.Cluster, box *packr.Box) (string, error) {
	calicoDeploymentTemplate, err := box.Resolve("tpl/calico-daemonset.yaml")
	if err != nil {
		return "", err
	}

	t, err := template.New("calico").Parse(calicoDeploymentTemplate.String())
	if err != nil {
		return "", err
	}

	var calicoDeploymentFile bytes.Buffer
	err = t.Execute(&calicoDeploymentFile, cl)
	if err != nil {
		return "", err
	}
	return calicoDeploymentFile.String(), nil
}

// GenerateFlannelDeploymentFile generates flannel deployment file from template
func GenerateFlannelDeploymentFile(cl *config.Cluster, box *packr.Box) (string, error) {
	flannelDeploymentTemplate, err := box.Resolve("tpl/flannel-daemonset.yaml")
	if err != nil {
		return "", err
	}

	t, err := template.New("flannel").Parse(flannelDeploymentTemplate.String())
	if err != nil {
		return "", err
	}

	var flannelDeploymentFile bytes.Buffer
	err = t.Execute(&flannelDeploymentFile, cl)
	if err != nil {
		return "", err
	}
	return flannelDeploymentFile.String(), nil
}

// GenerateWeaveDeploymentFile generates weave deployment file from template
func GenerateWeaveDeploymentFile(cl *config.Cluster, box *packr.Box) (string, error) {
	weaveDeploymentTemplate, err := box.Resolve("tpl/weave-daemonset.yaml")
	if err != nil {
		return "", err
	}

	t, err := template.New("weave").Parse(weaveDeploymentTemplate.String())
	if err != nil {
		return "", err
	}

	var weaveDeploymentFile bytes.Buffer
	err = t.Execute(&weaveDeploymentFile, cl)
	if err != nil {
		return "", err
	}
	return weaveDeploymentFile.String(), nil
}

// IsKnown returns bool if cluster exists
func IsKnown(clName string, provider *kind.Provider) (bool, error) {
	n, err := provider.ListNodes(clName)
	if err != nil {
		return false, err
	}
	if len(n) != 0 {
		return true, nil
	}
	return false, nil
}
