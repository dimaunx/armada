package utils

import (
	"bytes"
	"context"
	"io/ioutil"
	"net"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"text/template"

	"github.com/Masterminds/semver"
	"github.com/dimaunx/armada/pkg/cluster"
	"github.com/dimaunx/armada/pkg/constants"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	dockerclient "github.com/docker/docker/client"
	"github.com/gobuffalo/packr/v2"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v2"
)

type kubeConfig struct {
	APIVersion string `yaml:"apiVersion"`
	Clusters   []struct {
		Cluster struct {
			CertificateAuthorityData string `yaml:"certificate-authority-data"`
			Server                   string `yaml:"server"`
		} `yaml:"cluster"`
		Name string `yaml:"name"`
	} `yaml:"clusters"`
	Contexts []struct {
		Context struct {
			Cluster string `yaml:"cluster"`
			User    string `yaml:"user"`
		} `yaml:"context"`
		Name string `yaml:"name"`
	} `yaml:"contexts"`
	CurrentContext string `yaml:"current-context"`
	Kind           string `yaml:"kind"`
	Preferences    struct {
	} `yaml:"preferences"`
	Users []struct {
		Name string `yaml:"name"`
		User struct {
			ClientCertificateData string `yaml:"client-certificate-data"`
			ClientKeyData         string `yaml:"client-key-data"`
		} `yaml:"user"`
	} `yaml:"users"`
}

// PrepareKubeConfig modifies kubconfig file generated by kind.
func PrepareKubeConfig(cl *cluster.Cluster) error {
	var kubeconf kubeConfig

	currentDir, _ := os.Getwd()
	usr, err := user.Current()
	if err != nil {
		return errors.Wrap(err, "failed to get current user")
	}

	_ = os.MkdirAll(constants.LocalKubeConfigDir, os.ModePerm)
	_ = os.MkdirAll(constants.ContainerKubeConfigDir, os.ModePerm)
	kindKubeFileName := strings.Join([]string{"kind-config", cl.Name}, "-")
	kindKubeFilePath := filepath.Join(usr.HomeDir, ".kube", kindKubeFileName)
	newLocalKubeFile := filepath.Join(currentDir, constants.LocalKubeConfigDir, kindKubeFileName)
	newContainerKubeFile := filepath.Join(currentDir, constants.ContainerKubeConfigDir, kindKubeFileName)

	kubeFile, err := ioutil.ReadFile(kindKubeFilePath)
	if err != nil {
		return errors.Wrapf(err, "failed to read kube config %s.", kindKubeFilePath)
	}

	err = yaml.Unmarshal(kubeFile, &kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to read kube config %s.", kindKubeFilePath)
	}

	kubeconf.CurrentContext = cl.Name
	kubeconf.Contexts[0].Name = cl.Name
	kubeconf.Contexts[0].Context.Cluster = cl.Name
	kubeconf.Contexts[0].Context.User = cl.Name
	kubeconf.Clusters[0].Name = cl.Name
	kubeconf.Users[0].Name = cl.Name

	d, err := yaml.Marshal(&kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to marshal kube config.")
	}

	err = ioutil.WriteFile(newLocalKubeFile, d, 0644)
	if err != nil {
		return errors.Wrapf(err, "failed to save kube config %s.", newLocalKubeFile)
	}

	masterIP, err := GetMasterDockerIP(cl)
	if err != nil {
		return err
	}

	kubeconf.Clusters[0].Cluster.Server = "https://" + masterIP + ":6443"
	d, err = yaml.Marshal(&kubeconf)
	if err != nil {
		return errors.Wrapf(err, "failed to marshal kube config.")
	}

	err = ioutil.WriteFile(newContainerKubeFile, d, 0644)
	if err != nil {
		return errors.Wrapf(err, "failed to save kube config %s.", newContainerKubeFile)
	}
	return nil
}

// GetKubeConfigPath returns different kubeconfig paths for local and docker based runs
func GetKubeConfigPath(cl *cluster.Cluster) (string, error) {
	currentDir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	// Dummy destination
	conn, err := net.Dial("udp", "1.1.1.1:80")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	localAddr := conn.LocalAddr().(*net.UDPAddr)
	ctx := context.Background()
	dockerCli, err := dockerclient.NewEnvClient()
	if err != nil {
		return "", err
	}

	networkFilter := filters.NewArgs()
	networkFilter.Add("driver", "bridge")
	networks, err := dockerCli.NetworkList(ctx, types.NetworkListOptions{Filters: networkFilter})
	if err != nil {
		return "", err
	}

	for _, network := range networks {
		dockerNet := network.IPAM.Config[0].Subnet
		_, ipNet, err := net.ParseCIDR(dockerNet)
		if err != nil {
			return "", err
		}

		if ipNet.Contains(localAddr.IP) {
			log.Debugf("Running in a container. Bridge network: %s, ip: %s.	", dockerNet, localAddr.IP)
			kubeConfigFilePath := filepath.Join(currentDir, constants.ContainerKubeConfigDir, strings.Join([]string{"kind-config", cl.Name}, "-"))
			return kubeConfigFilePath, nil
		}
	}
	log.Debugf("Running in a host mode. ip: %s.", localAddr.IP)
	kubeConfigFilePath := filepath.Join(currentDir, constants.LocalKubeConfigDir, strings.Join([]string{"kind-config", cl.Name}, "-"))
	return kubeConfigFilePath, nil
}

// GetMasterDockerIP gets control plain master docker internal ip
func GetMasterDockerIP(cl *cluster.Cluster) (string, error) {
	ctx := context.Background()
	dockerCli, err := dockerclient.NewEnvClient()
	if err != nil {
		return "", err
	}

	containerFilter := filters.NewArgs()
	containerFilter.Add("name", strings.Join([]string{cl.Name, "control-plane"}, "-"))
	containers, err := dockerCli.ContainerList(ctx, types.ContainerListOptions{
		Filters: containerFilter,
		Limit:   1,
	})
	if err != nil {
		return "", err
	}
	return containers[0].NetworkSettings.Networks["bridge"].IPAddress, nil
}

// Iterate func map for config template
func Iterate(start, end int) (stream chan int) {
	stream = make(chan int)
	go func() {
		for i := start; i <= end; i++ {
			stream <- i
		}
		close(stream)
	}()
	return
}

// GenerateConfig creates kind config file
func GenerateConfig(cl *cluster.Cluster, clusterConfigFile, configTemplate string) error {
	t, err := template.New("config").Funcs(template.FuncMap{"Iterate": Iterate}).Parse(configTemplate)
	if err != nil {
		return err
	}

	f, err := os.Create(clusterConfigFile)
	if err != nil {
		return errors.Wrapf(err, "creating config file %s", clusterConfigFile)
	}

	err = t.Execute(f, cl)
	if err != nil {
		return errors.Wrapf(err, "creating config file %s", clusterConfigFile)
	}

	if err := f.Close(); err != nil {
		return err
	}

	log.Debugf("ClustersConfig files for %s generated.", cl.Name)
	return nil
}

// CreateEnvironment creates custom environment
func CreateEnvironment(i int, flags *cluster.Flagpole, wg *sync.WaitGroup) error {
	currentDir, err := os.Getwd()
	if err != nil {
		return err
	}

	podIP := net.ParseIP(constants.PodCidrBase)
	podIP = podIP.To4()
	podIP[1] += byte(4 * i)

	serviceIP := net.ParseIP(constants.ServiceCidrBase)
	serviceIP = serviceIP.To4()
	serviceIP[1] += byte(i)

	cl := &cluster.Cluster{
		Cni:                 "kindnet",
		Name:                constants.ClusterNameBase + strconv.Itoa(i),
		NumWorkers:          constants.NumWorkers,
		PodSubnet:           podIP.String() + constants.PodCidrMask,
		ServiceSubnet:       serviceIP.String() + constants.ServiceCidrMask,
		DNSDomain:           constants.ClusterNameBase + strconv.Itoa(i) + ".local",
		KubeAdminAPIVersion: "kubeadm.k8s.io/v1beta2",
	}

	if flags.ImageName != "" {
		tgt := semver.MustParse("1.15")
		results := strings.Split(flags.ImageName, ":v")
		if len(results) == 2 {
			sver := semver.MustParse(results[len(results)-1])
			if sver.LessThan(tgt) {
				cl.KubeAdminAPIVersion = "kubeadm.k8s.io/v1beta1"
			}
		} else {
			return errors.Errorf("%q: Could not extract version from %s, split is by ':v', example of correct image name: kindest/node:v1.15.3.", cl.Name, flags.ImageName)
		}
	}

	configDir := filepath.Join(currentDir, constants.KindConfigDir)
	err = os.MkdirAll(configDir, os.ModePerm)
	if err != nil {
		return errors.Wrapf(err, "%s", cl.Name)
	}

	box := packr.New("configs", "../../configs")

	clusterConfigTemplate, err := box.Resolve("tpl/cluster-config.yaml")
	if err != nil {
		return errors.Wrapf(err, "%s", cl.Name)
	}

	kindConfigFilePath := filepath.Join(configDir, cl.Name+"-kind-config.yaml")
	kubeConfigFilePath, err := GetKubeConfigPath(cl)
	if err != nil {
		return errors.Wrapf(err, "%s", cl.Name)
	}

	if flags.Weave {
		cl.Cni = "weave"
		flags.Wait = 0

		err = GenerateConfig(cl, kindConfigFilePath, clusterConfigTemplate.String())
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = cluster.CreateKindCluster(cl, *flags, kindConfigFilePath)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = PrepareKubeConfig(cl)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		weaveDeploymentTemplate, err := box.Resolve("tpl/weave-daemonset.yaml")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		t, err := template.New("weave").Parse(weaveDeploymentTemplate.String())
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		var weaveDeploymentFile bytes.Buffer
		err = t.Execute(&weaveDeploymentFile, cl)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = DeployResources(cl, weaveDeploymentFile.String(), kubeConfigFilePath, "Weave")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = WaitForDaemonSet(cl, kubeConfigFilePath, "kube-system", "weave-net")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = WaitForDeployment(cl, kubeConfigFilePath, "kube-system", "coredns")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

	} else if flags.Flannel {
		cl.Cni = "flannel"
		flags.Wait = 0

		err = GenerateConfig(cl, kindConfigFilePath, clusterConfigTemplate.String())
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = cluster.CreateKindCluster(cl, *flags, kindConfigFilePath)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = PrepareKubeConfig(cl)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		flannelDeploymentTemplate, err := box.Resolve("tpl/flannel-daemonset.yaml")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		t, err := template.New("flannel").Parse(flannelDeploymentTemplate.String())
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		var flannelDeploymentFile bytes.Buffer
		err = t.Execute(&flannelDeploymentFile, cl)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = DeployResources(cl, flannelDeploymentFile.String(), kubeConfigFilePath, "Flannel")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = WaitForDaemonSet(cl, kubeConfigFilePath, "kube-system", "kube-flannel-ds-amd64")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = WaitForDeployment(cl, kubeConfigFilePath, "kube-system", "coredns")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

	} else if flags.Calico {
		cl.Cni = "calico"
		flags.Wait = 0

		err = GenerateConfig(cl, kindConfigFilePath, clusterConfigTemplate.String())
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = cluster.CreateKindCluster(cl, *flags, kindConfigFilePath)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = PrepareKubeConfig(cl)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		calicoCrdFile, err := box.Resolve("tpl/calico-crd.yaml")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = DeployCrdResources(cl, calicoCrdFile.String(), kubeConfigFilePath)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		calicoDeploymentTemplate, err := box.Resolve("tpl/calico-daemonset.yaml")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		t, err := template.New("calico").Parse(calicoDeploymentTemplate.String())
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		var calicoDeploymentFile bytes.Buffer
		err = t.Execute(&calicoDeploymentFile, cl)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = DeployResources(cl, calicoDeploymentFile.String(), kubeConfigFilePath, "Calico")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = WaitForDaemonSet(cl, kubeConfigFilePath, "kube-system", "calico-node")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = WaitForDeployment(cl, kubeConfigFilePath, "kube-system", "coredns")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

	} else {
		err = GenerateConfig(cl, kindConfigFilePath, clusterConfigTemplate.String())
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = cluster.CreateKindCluster(cl, *flags, kindConfigFilePath)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = PrepareKubeConfig(cl)
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}
	}

	if flags.Tiller {
		tillerDeploymentFile, err := box.Resolve("helm/tiller-deployment.yaml")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = DeployResources(cl, tillerDeploymentFile.String(), kubeConfigFilePath, "Tiller")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}

		err = WaitForDeployment(cl, kubeConfigFilePath, "kube-system", "tiller-deploy")
		if err != nil {
			return errors.Wrapf(err, "%s", cl.Name)
		}
	}
	wg.Done()
	return nil
}
